/// Developer notes. This will need some re-organization once we start thinking through
/// varied valuations (e.g. value over a time range, value multiple securities in the same
/// request/etc. For now, the caller will need to make individual requests.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValuationRequestProto {
    #[prost(string, tag = "1")]
    pub object_class: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Only supports GET, since there is no backing store, so CREATE isn't relevant. SEARCH isn't relevant either.
    /// VALIDATE could be implemented later, e.g. if the caller wants to check their inputs are correct.
    #[prost(enumeration = "super::util::RequestOperationTypeProto", tag = "10")]
    pub operation_type: i32,
    /// The list of measures to be generated by this request, e.g. MARKET_VALUE, CURRENT_YIELD, etc.
    #[prost(
        enumeration = "super::super::models::position::MeasureProto",
        repeated,
        tag = "30"
    )]
    pub measures: ::prost::alloc::vec::Vec<i32>,
    /// The full security object for which we are going to run the valuation
    #[prost(message, optional, tag = "20")]
    pub security_input: ::core::option::Option<
        super::super::models::security::SecurityProto,
    >,
    /// The positions we are going to value.
    #[prost(message, optional, tag = "21")]
    pub position_input: ::core::option::Option<
        super::super::models::position::PositionProto,
    >,
    /// The price we are going to use for the valuation.
    #[prost(message, optional, tag = "22")]
    pub price_input: ::core::option::Option<super::super::models::price::PriceProto>,
    /// The asof datetime for the valuation.
    #[prost(message, optional, tag = "23")]
    pub asof_datetime: ::core::option::Option<
        super::super::models::util::LocalTimestampProto,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValuationResponseProto {
    #[prost(string, tag = "1")]
    pub object_class: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "20")]
    pub valuation_request: ::core::option::Option<ValuationRequestProto>,
    #[prost(message, repeated, tag = "30")]
    pub measure_results: ::prost::alloc::vec::Vec<
        super::super::models::position::MeasureMapEntry,
    >,
}
